# ADR-002: Миграция SQLite → PostgreSQL

**Дата:** 2026-02-01  
**Статус:** Proposed

---

## Контекст

SQLite обеспечивает простоту и zero-config для single-user и малых команд, но при росте (>30 пользователей, параллельные write) возникают ограничения: один writer, lock conflicts, `SQLITE_BUSY`. US-8 (WAL, busy_timeout, retry) смягчает, но не устраняет. Для масштабирования и операционной предсказуемости нужна БД с поддержкой конкурентных записей.

## Решение

Миграция на PostgreSQL с сохранением доменной логики. Вводим абстракцию `DbAdapter` — единый интерфейс поверх SQLite и Postgres. По умолчанию SQLite (локальная разработка, CI), Postgres — через `DB_PROVIDER=postgres` и `DATABASE_URL`. Миграции приводятся к диалекту Postgres; для SQLite остаётся совместимый набор или отдельный провайдер.

## Альтернативы

| Вариант | Плюсы | Минусы | Почему не выбран |
|---------|-------|--------|------------------|
| Остаться на SQLite | Простота, нет инфра | Один writer, lock conflicts | Ограничение при росте |
| MySQL | Широко распространён | Другая семантика, лицензия | Postgres — стандарт для нового кода |
| CockroachDB | Распределённость | Сложность, оверкилл | Ранняя стадия; Postgres достаточно |

## Последствия

- **Код:** `lib/db.ts` → фабрика adapter по `DB_PROVIDER`; SQL переводится на диалект (AUTOINCREMENT→SERIAL, datetime('now')→now())
- **Процесс:** CI — SQLite по умолчанию; опциональный job на Postgres; миграционный скрипт SQLite→Postgres
- **Риски:** расхождения диалектов; необходимость тестировать оба провайдера для критичных путей
