#!/usr/bin/env node
/**
 * Send structured Slack alert from slack-payload.json (generated by independent-verify).
 *
 * Usage: node scripts/slack-notify.mjs --payload <path> [--webhook <url>]
 * Env: SLACK_WEBHOOK_URL (required if --webhook not provided)
 */
import fs from 'node:fs';
import path from 'node:path';
import https from 'node:https';

function usage() {
  console.error('Usage: node scripts/slack-notify.mjs --payload <path> [--webhook <url>]');
  process.exit(1);
}

function argVal(flag) {
  const i = process.argv.indexOf(flag);
  if (i === -1) return null;
  return process.argv[i + 1] || null;
}

function postJson(url, body) {
  return new Promise((resolve, reject) => {
    const u = new URL(url);
    const data = Buffer.from(JSON.stringify(body), 'utf8');
    const req = https.request(
      {
        method: 'POST',
        hostname: u.hostname,
        path: u.pathname + (u.search || ''),
        port: u.port || 443,
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': data.length,
        },
      },
      (res) => {
        const chunks = [];
        res.on('data', (c) => chunks.push(c));
        res.on('end', () => {
          const txt = Buffer.concat(chunks).toString('utf8');
          if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
            resolve({ ok: true, status: res.statusCode, body: txt });
          } else {
            resolve({ ok: false, status: res.statusCode || 0, body: txt });
          }
        });
      }
    );
    req.on('error', reject);
    req.write(data);
    req.end();
  });
}

function toSlackMessage(p) {
  const top = Array.isArray(p?.anchoring?.top) ? p.anchoring.top : [];
  const lines = [];
  for (const it of top) {
    const rb = it.runbook ? ` | runbook: ${it.runbook}` : '';
    lines.push(`â€¢ ${it.severity}/${it.type}: ${it.count}${rb}`);
  }

  const text =
    `*${p.title}*\n` +
    `status: *${String(p.status).toUpperCase()}*\n` +
    (p.pack_sha256 ? `pack_sha256: \`${p.pack_sha256}\`\n` : '') +
    `hits: ${p?.anchoring?.issues_hits ?? '?'} | total: ${p?.anchoring?.issues_total ?? '?'}` +
    (p?.anchoring?.issues_deduped != null ? ` (deduped: ${p.anchoring.issues_deduped})` : '') +
    `\n` +
    `signature: ${p?.signature?.ok ? 'OK' : 'FAIL'}${p?.signature?.key_id ? ` (key_id=${p.signature.key_id})` : ''}\n` +
    (lines.length ? `\n*Top issues:*\n${lines.join('\n')}\n` : '');

  return { text };
}

async function main() {
  const payloadPath = argVal('--payload');
  const webhook = argVal('--webhook') || process.env.SLACK_WEBHOOK_URL || null;
  if (!payloadPath) usage();
  if (!webhook) {
    console.error('Missing webhook. Provide --webhook or SLACK_WEBHOOK_URL.');
    process.exit(1);
  }

  const abs = path.resolve(payloadPath);
  if (!fs.existsSync(abs)) {
    console.error(`Payload file not found: ${abs}`);
    process.exit(1);
  }
  const p = JSON.parse(fs.readFileSync(abs, 'utf8'));

  const unackCritical = p?.ack?.unacknowledged_critical ?? null;
  const passed = p?.result?.passed ?? p?.status === 'pass';
  if (!process.argv.includes('--force') && passed) {
    console.log('Slack suppressed: verify passed');
    return;
  }
  if (!process.argv.includes('--force') && unackCritical !== null && unackCritical === 0 && (p?.ack?.unacknowledged ?? 0) > 0) {
    const msg = toSlackMessage({ ...p, title: `Independent verify: all critical acked (${p.title || 'info'})`, status: 'pass' });
    const res = await postJson(webhook, msg);
    if (!res.ok) {
      console.error(`Slack notify failed: HTTP ${res.status}`);
      process.exit(2);
    }
    console.log('Slack notified (downgraded: all critical acked)');
    return;
  }

  const msg = toSlackMessage(p);
  const res = await postJson(webhook, msg);
  if (!res.ok) {
    console.error(`Slack notify failed: HTTP ${res.status}`);
    console.error(res.body);
    process.exit(2);
  }
  console.log(`Slack notified: HTTP ${res.status}`);
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch((e) => {
    console.error(e?.stack || String(e));
    process.exit(2);
  });
}
